---
title: Java面试题汇总
date: 2021-04-21 14:09:21
tags:
---
#### Java并发篇
一、Java如何开启线程？怎么保证线程安全？
线程和进程的区别：进程是操作系统进行`资源分配`的最小单元，线程是操作系统进行`任务调度`的最小单元。线程属于进程。
如何开启线程？
1、继承Thread类，重写run方法；
2、实现Runnable接口，实现run方法；
3、实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程执行的返回值；
4、通过线程池来开启线程；
怎么保证线程安全？
加锁
1、JVM提供的锁，也就是synchronized 关键字；
2、JDK提供的各种锁；


二、volatile 和 synchronized 有什么区别？volatile 能不能保证线程安全？DCL(Double Check Lock)单例为什么要加volatile？
1、synchronized 关键字，用来加锁。volatile 只是保证变量的线程可见性，通常适用于一个线程写，多个线程读的场景。
2、volatile 不能保证线程安全，volatile 关键字只能保证线程可见性，不能保证原子性。
3、volatile 防止指令重排，在DCL中，防止高并发下，指令重排造成的线程安全问题。


三、Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？
1、Java的锁就是在对象的MarkWord中记录一个锁状态。无锁、偏向锁、轻量级锁、重量级锁对应不同的锁状态。
2、Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。
3、无锁、偏向锁、轻量级锁、重量级锁。


四、谈谈你对AQS的理解。AQS如何实现可重入锁ReentrantLock？
1、AQS是一个Java线程同步的框架，是JDK中很多锁工具的核心实现框架。
2、在AQS中，维护一个整型变量state 和 一个线程组成的双向链表队列。其中，这个线程队列用来给线程排队的，而state用来控制线程排队或放行的。在不同场景下，有不同的意义。
3、在可重入锁这个场景下，state就用来表示加锁的次数，0表示无锁，每加一次锁，state就加1，释放锁state就减1。


五、有A、B、C 三个线程，如何保证三个线程同时执行？如何在高并发情况下保证三个线程顺序执行？如何保证三个线程有序交错执行？
CountDownLatch、CyclicBarrier、Semaphore
1、CountDownLatch、CyclicBarrier
2、join
3、wait、notify

六、如何对一个字符串快速排序？
Fork/Join框架
归并排序


#### Java网络通信篇
一、TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次？
TCP Transfer Control Protocol 是一种面向连接的、可靠的、传输层通信协议。
特点：面向连接的，点对点的通信，高可靠的，效率比较低，占用系统资源比较多。

UDP User Datagram Protocol 是一种无连接的，不可靠的传输层通信协议。
特点：不需要连接，发送方不管接收方有没有准备好，直接发消息，可以进行广播发送，传输不可靠，有可能丢失消息；效率比较高；协议比较简单，占用系统资源比较少。

TCP建立连接三次握手，断开连接四次挥手。
如果是两次握手，可能造成连接资源浪费的情况。

二、Java有哪几种IO模型？有什么区别？
BIO 同步阻塞IO
可靠性差，吞吐量低，适用于连接比较少且比较固定的场景，JDK1.4之前唯一的选择。编程模型最简单。

NIO 同步非阻塞IO
可靠性比较好，吞吐量比较高，适用于连接数比较多，并且连接比较短（轻操作）的场景，例如聊天室。JDK1.4开始支持。
编程模型复杂。

AIO 异步非阻塞IO
可靠性是最好的，吞吐量非常高。适用于连接比较多，并且连接比较长（重操作）的场景。例如相册服务器。
编程模型比较简单，需要操作系统支持。



三、Java NIO 的几个核心组件是什么？分别有什么作用？
Channel、Buffer、Selector
Channel 类似于流，每个Channel对应一个Buffer缓冲区，Channel会注册到Selector 上。
Selector 会根据Channel上发生的读写事件，将请求交给某个空闲的线程处理。Selector 对应一个或多个线程。
Buffer 和 Channel 都是可读可写的。


四、Select Poll和EPoll 有什么区别？
它们是NIO中多路复用的三种实现机制，是由操作系统提供的。

Java 的NIO当中使用哪种机制？可以查看JDK中 DefaultSelectorProvider 源码，在Windows和Linux 实现方式是不同的。
在Windows下是 WindowsSelectorProvider，而Linux下，根据Linux内核版本，2.6版本以上就是EPollSelectorProvider，否则就是默认的 PollSelectorProvider。


五、描述Http 和 Https的区别
HTTP: 是互联网上应用最为广泛的一种网络通信协议，基于TCP，可以使浏览器工作更为高效，减少网络传输。
HTTPS: 是HTTP的加强版，可以认为是HTTP+SSL（Secure Socket Layer）。在HTTP的基础上增加了一系列的安全机制。一方面保证
数据传输安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。

主要区别：
1、HTTP的连接是简单无状态的，HTTPS的数据传输是经过证书加密的，安全性更高。
2、HTTP是免费的，而HTTPS需要申请证书，而证书通常是需要收费的，并且费用一般不低。
3、它们的传输协议不同，所以它们使用的端口也不一样，HTTP默认是80端口，而HTTPS默认是443端口。

HTTPS的缺点：
1、HTTPS的握手协议比较耗时，所以会影响服务的响应速度和吞吐量；
2、HTTPS也并不是完全安全的，它的证书体系并不是完全安全的，HTTPS在面对DDOS这样的攻击时，几乎起不到任何作用。


#### 消息队列篇
一、MQ有什么用？有哪些具体的使用场景？

MQ：Message Queue ，消息队列。队列是一种FIFO先进先出的数据结构。消息由生产者发送到MQ进行排队，然后由消费者对消息进行处理。

MQ的作用主要有三个方面：

1、异步

作用：异步将提高系统的响应速度和吞吐量。

2、解耦

作用：服务之间进行解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性。

另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。

3、削峰

作用：以稳定的系统资源应对突发的流量冲击。

MQ的缺点：

1、系统可用性降低，一旦MQ宕机，整个业务系统就会产生影响。高可用

2、系统的复杂度提高：引入MQ之后，数据链路就会变得很复杂。如何保证消息不丢失？消息不会重复调用？怎么保证消息的顺序性？

3、数据一致性：A系统发消息，需要由B、C两个系统一同处理。如果B系统处理成功、C系统处理失败，这就会造成数据一致性的问题。



二、如何进行产品选型？

Kafka

优点：吞吐量非常大，性能非常好，集群高可用。

缺点：会丢数据，功能比较单一。

使用场景：日志分析，大数据采集。



RabbitMQ

优点：消息可靠性，功能全面。

缺点：吞吐量比较低，消息积累会严重影响。erlang语言不好定制。

使用场景：小规模场景。



RocketMQ

优点：高吞吐、高性能、高可用，功能非常全面。

缺点：开源版功能不如商业版。官方文档和周边生态还不够成熟，客户端只支持java。

使用场景：几乎是所有场景。



三、如何保证消息不丢失？

1、生产者发送消息不丢失

Kafka：消息发送 + 回调。

RocketMQ：1)、消息发送 + 回调；2)、事务消息。

RabbitMQ：

1)、消息发送 + 回调；

2)、手动事务，

channel.txSelect() 开启事务，channel.txCommit()提交事务，channel.txRollback()回滚事务。这种方式对channel是会产生阻塞的，造成吞吐量下降。

3)、Publish Confirm，整个处理流程跟RocketMQ的事务消息基本是一致的。



2、MQ主从消息同步不丢失

RocketMQ：1)、普通集群中，同步同步消息、异步同步消息。异步同步消息效率更高，但是由丢失消息的风险。同步同步消息不会丢消息。2)、Dledger集群-两阶段提交。

RabbitMQ：普通集群，消息是分散存储的，节点之间不会主动进行消息的同步，是有可能丢失消息的。镜像集群，会在节点之间主动进行数据同步，这样数据安全性得到提高。

Kafka：通常都是在允许消息少量丢失的场景。acks 0 1 all 参数配置。



3、MQ消息存盘不丢失

RocketMQ：同步刷盘、异步刷盘，异步刷盘效率更高，但是有可能丢消息。同步刷盘消息安全性更高，但是效率会降低。

RabbitMQ：将队列配置成持久化队列。新增的Quorum类型的队列，会采用Raft协议来进行消息同步。



4、MQ消费者消费消息不丢失

RocketMQ：使用默认的方式消费就行，不要采用异步方式。

RabbitMQ：autoCommit -> 手动提交offset。

Kafka：手动提交offset。



四、如何保证消息消费的幂等性？

其实就是解决消费者重复消费消息的问题。

所有MQ产品都没有提供主动解决幂等性的机制，需要由消费者自行控制。

RocketMQ：给每个消息分配MessageID，这个MessageID就可以作为消费者判断幂等的依据，这种方式不太建议。

最好的方式就是自己带一个有业务标识的ID来进行幂等判断，比如订单ID。



五、如何保证消息的顺序消费？

全局有序和局部有序：MQ只需要保证局部有序，不需要保证全局有序。

生产者把一组有序的消息放到同一个队列当中，而消费者一次消费整个队列当中的消息。

RocketMQ中有完整的设计，但是在RabbitMQ和Kafka当中并没有完整的设计，需要自己进行配置。

RabbitMQ：要保证目标exchange只对应一个队列，并且一个队列只对应一个消费者。

Kafka: 生产者通过定制partition分配规则，将消息分配到同一个partition。topic下只对应一个消费者。

消息顺序消费会影响性能。



六、如何保证消息的高效读写？



七、使用MQ如何保证分布式事务的最终一致性？

分布式事务：业务相关的多个操作，保证它们同时成功或同时失败。

最终一致性：与之对应的就是强一致性。

MQ中要保证事务的最终一致性，就需要做到两点

1、生产者要保证100%的消息投递。事务消息机制。

2、消费者需要保证幂等消费，唯一ID + 业务自己实现幂等。



分布式MQ的三种语义：

at least once

at most once

exactly once



八、让你设计一个MQ，你会如何设计？


















































